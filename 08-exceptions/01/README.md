# Задача 1. Поломанная игра

## Описание

Ознакомьтесь с проектом по [ссылке](https://repl.it/@netologycsharp/ExceptionsErrorsHomework). Ваша задача найти и исправить все ошибки, а так же избавиться от всех блоков `try/catch`.

При правильном исправлении всех ошибок проект должен корректно выполняться и вычислять победителя.

# RPG игра

По легенде некий разработчик решил создать простую RPG игру и решил начать с разработки персонажей. В игре присутствуют различные персонажи со следующими характеристиками:

- жизнь
- мана
- скорость
- атака
- ловкость
- удача

Также реализованы основные персонажи:

1. Воин (`Warrior`)
2. Маг (`Mage`)
3. Лучник (`Archer`)

и улучшенные:

1. Гном (`Dwarf`) - улучшенный Воин
2. Демиург (`Demiurge`) - улучшенный Маг
3. Арбалетчик (`Crossbowman`) - улучшенный Лучник

У каждого воина в руках есть оружие.

## Оружие

В игре присутствуют `меч`, `лук` и `посох`, а также их улучшенные версии: `секира`, `длинный лук` и `посох бури`.

Реализован базовый класс `Weapon` со следующими полями:

1. _Name_ - название
2. _Attack_ - размер атаки
3. _Durability_ - прочность
4. _Range_ - дальность

свойствами:

1. _IsBroken_, показывающее, сломано ли оружие. Должно возвращать _false_ при `Durability` более 0 и _true_ в противном случае.

и методами (действиями оружия):

1. Метод _TakeDamage(int damage)_, добавляющий повреждение от соперника.
   Всё повреждение уменьшает значение прочности оружия (поле _Durability_).
   Значение Durability не должно падать ниже 0.
2. Метод _GetDamage()_, рассчитывающий урон от удара данным оружием.
   Если прочность оружия (_Durability_) больше или равна 30% от изначального, необходимо выдать значение
   свойства attack иначе `Attack / 2`. При прочности менее 0, метод возвращает 0.

## Готовые оружия

В игре присутствуют базовые и улучшенные оружия

Таблица 1. Классы оружия.

| class | Name  | Attack | Durability | Range |
| ----- | ----- | ------ | ---------- | ----- |
| Arm   | Рука  | 1      | Infinity   | 1     |
| Bow   | Лук   | 10     | 200        | 3     |
| Sword | Меч   | 25     | 500        | 1     |
| Knife | Нож   | 5      | 300        | 1     |
| Staff | Посох | 8      | 300        | 2     |

Таблица 2. Классы усиленного оружия. Прочерк («-») - свойство берётся из **наследуемого** класса.

| class      | наследуется от | Name        | Attack | Range | Durability |
| ---------- | -------------- | ----------- | ------ | ----- | ---------- |
| LongBow    | Bow            | Длинный лук | 15     | 4     | -          |
| Axe        | Sword          | Секира      | 27     | -     | 800        |
| StormStaff | Staff          | Посох Бури  | 10     | 3     | -          |

## Персонажи

Реализован базовый класс игрока _Player_ со следующими полями и их начальными значениями:

1. Life = 100 - количество здоровья
2. Magic = 20 - количество маны
3. Speed = 1 - скорость
4. Attack = 10 - уровень атаки
5. Agility = 5 - ловкость
6. PersonLuck = 10 - удача
7. Description = 'Игрок' - тип игрока
8. Weapon = new Arm() - начальное оружие
9. Name - имя игрока
10. Position - положение игрока на оси координат

Свойствами:

1. Luck - рандомная удача игрока
2. isDodged - возможность уворота
3. IsAttackBlocked - возможность блокировки удара
4. IsDead - является ли игрок мёртвым или нет

И методами:

1. _Turn(Player[] players)_ - каждый ход игрок совершает следующую последовательность действий (именно в таком порядке):
   выбирает врага, если у бойца нету врага (_chooseEnemy_), двигается (_moveToEnemy_), наносит удар (_tryAttack_).
2. _TakeDamage(double damage)_, принимающий полученный урон. Урон полностью вычитается из здоровья
   персонажа. Значение здоровья персонажа не может падать меньше 0.
3. _TakeAttack(int damage)_, который наносит удар другому игроку.
   Работа метода идёт в следующем порядке: 1. Если атака была заблокирована (_IsAttackBlocked_), урон приходится по оружию (_weapon.TakeDamage_). 2. Если произошло уклонение (_isDodged_), урон не засчитывается 3. В иных случаях игрок получает урон, равный damage
4. _getDamage(int distance)_, рассчитывающий силу удара по формуле:
   `(attack + weaponDamage) * getLuck() / distance`. _distance_ - расстояние между игроками,
   _weaponDamage_ - значение урона текущего оружия у игрока ( _weapon.GetDamage()_).
   При значении _distance_, превышающем свойство range оружия, метод возвращает 0.
5. _tryAttack(Player enemy)_, реализует атаку игроком.
   1. Рассчитать расстояние между игроком и врагом (_distance_).
   2. Если дальность оружия (_weapon.Range_) не достаёт (больше _distance_) до врага, атака не засчитывается
      и метод прекращает работу.
   3. В ином случае записывается износ оружию (_weapon.takeDamage_) на `10 * getLuck()`
   4. Нанесите урон (_getDamage_) противнику (_enemy.TakeAttack_)
   5. Если игроки имеют одно и то же положение (_Position_), атакуемый отскакивает
      на 1 деление вправо и принимает урон (_enemy.TakeAttack_) с удвоенной силой (`damage * 2`)
6. _checkWeapon_, реализует проверку поломанности оружия. В случае, если оружие износилось (_weapon.IsBroken_),
   игрок получает следущее классом ниже. Так, для класса _Warrior_ это будет
   _Sword_ -> _Knife_ -> _Arm_. Детали смотрите в колонке «Основное оружие» соответствующего класса.
   P.S. У всех есть нож и голые руки.
7. _moveLeft(int distance)_ и _moveRight(int distance)_ - методы передвижения. За один вызов игрок может сместиться
   на расстояние _distance_, но не более значения свойства _speed_. _moveLeft_ уменьшает значение _position_,
   _moveRight_ увеличивает.
8. _move(int distance)_ - метод передвижения. Если distance меньше нуля, вызывается _moveLeft(distance)_, иначе
   и _moveRight(distance)_.
9. _moveToEnemy(Player enemy)_, котрый осуществляет движение по направлению к врагу.
10. _chooseEnemy(Player[] players)_, где players - массив живых игроков на поле. Метод выбирает для игрока противника с минимальным здоровьем, того кто находится ближе всех.

## Готовые персонажи

В игре присутствуют уже готовые персонажи бойцов и их улучшенные версии.

Таблица 3. Классы бойцов. Прочерк («-») - свойство берётся из базового класса.

| class   | life | magic | speed | attack | agility | luck | description | weapon    | Основное оружие       |
| ------- | ---- | ----- | ----- | ------ | ------- | ---- | ----------- | --------- | --------------------- |
| Warrior | 120  | -     | 2     | 10     | -       | -    | Воин        | new Sword | Sword -> Knife -> Arm |
| Archer  | 80   | 35    | -     | 5      | 10      | -    | Лучник      | new Bow   | Bow -> Knife -> Arm   |
| Mage    | 70   | 100   | -     | 5      | 8       | -    | Маг         | new Staff | Staff -> Knife -> Arm |

Таблица 4. Классы улучшенных бойцов. Прочерк («-») - свойство берётся из **наследуемого** класса.

| class       | наследуется от | life | magic | speed | attack | agility | luck | description | weapon         | Основное оружие            |
| ----------- | -------------- | ---- | ----- | ----- | ------ | ------- | ---- | ----------- | -------------- | -------------------------- |
| Dwarf       | Warrior        | 130  | -     | -     | 15     | -       | 20   | Гном        | new Axe        | Axe -> Knife -> Arm        |
| Crossbowman | Archer         | 85   | -     | -     | 8      | 20      | 15   | Арбалетчик  | new LongBow    | LongBow -> Knife -> Arm    |
| Demiurge    | Mage           | 80   | 120   | -     | 6      | -       | 12   | Демиург     | new StormStaff | StormStaff -> Knife -> Arm |

## Особенности персонажей

1. _Archer.GetDamage(int distance)_: сила удара рассчитывается по формуле
   `(Attack + Weapon.Attack) * Luck * distance / Weapon.Range`
2. _Warrior.TakeDamage(double damage)_: при уровне здоровья менее 50%, _Luck_ > 0.8 и достаточном уровне маны, урон вычитается из маны, а не из здоровья. При нулевом значении маны урон вычитается из здоровья.
3. _Mage.TakeDamage(double damage)_: При уровне маны более 50%, маг получает урон в 1.5 раза меньше базового и
   уменьшает значение маны на 12.
4. _Dwarf.TakeDamage(double damage)_: Каждый шестой удар соперника наносит в 2 раза меньше урона.
5. _Demiurge.getDamage(int distance)_: При уровне маны > 0 и удачи > 0.6, наносимый урон увеличавется в 1.5 раза.

## Игровой процесс

Методы _Play(Player[] takenPlayers)_, который принимает массив игроков. И выполняется до тех пор, пока на поле не останется один игрок. Игра состоит из шагов, где каждый игрок сначала проверяется: живой ли он? Если он мертв, то он удаляется с поля и ход передаётся следующему игроку. Если игрок жив, то выполняется его ход.

---

### Подсказки

> Не читайте этот раздел сразу, попытайтесь сначала решить задачу самостоятельно :)

<details>

<summary>Подсказка 1</summary>

Не стесняйтесь запускать проект - если будут ошибки, то вам укажут, в каком файле и на какой строчке есть ошибка, так можно сразу перемещаться в нужное место :)

</details>
